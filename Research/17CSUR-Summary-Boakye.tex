\documentclass[dvips,12pt]{article}

% Any percent sign marks a comment to the end of the line

% Every latex document starts with a documentclass declaration like this
% The option dvips allows for graphics, 12pt is the font size, and article
%   is the style

\usepackage[pdftex]{graphicx}
\usepackage{url}
\usepackage{amsbsy}
\usepackage{amsmath}
\usepackage{array}
\newcolumntype{L}{>{\centering\arraybackslash}m{2cm}}


% These are additional packages for "pdflatex", graphics, and to include
% hyperlinks inside a document.
\setlength{\oddsidemargin}{0.25in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

% These force using more of the margins that is the default style

\begin{document}

% Everything after this becomes content
% Replace the text between curly brackets with your own

\title{Control Flow Integrity: Security Precision and Performance - A Summary}
\author{Boakye Dankwa}
\date{\today}

% You can leave out "date" and it will be added automatically for today
% You can change the "\today" date to any text you like


\maketitle

% This command causes the title to be created in the document

%\section{Abstract}
Control-Flow Integrity (CFI) shows promise to defeat control flow modification attacks such as remote code injection, Return-Oriented Programing (ROP) and code-reuse, that expoit memory corruption vulnerabilities in C/C++ programs. The technique has been researched and improved upon by researchers and has been integrated into products such as LLVM and some Microsoft products. Current CFI evaluations usually use the SPEC2006 benchmark and Average Indirect-target Reduction (AIR) to measure performance and security precision respectively. Control-Flow Integrity: Security Precision and Performance \cite{DBLP:journals/corr/BurowCBPNLF16} systematize various CFI implementations and their trade-offs, and propose a novel way of evaluating these implementations against security precision and performance.
\newline
\newline
The authors first described CFI mechanisms as consisting of an analysis and a runtime component. The analysis component constructs a Control-Flow Graph(CFG), which approximates the set of control-flow transfers in the program, from the source code or binary. The CFG is then used by the runtime to restrict program execution flow by validating indirect control-flow transfer against the CFG edges. They classified control-flow transfer into nine categories from CF.1 (backward control flow such as return instruction ) to CF.9 (control flow that supports features such as dynamic linking) based on the kind of control flow (\textit{direct, indirect, jump, return} or \textit{call}) and supported language constructs (\textit{such as function pointers and vtables}). They further explained that CFG is subject to over-approximation, making the precision of the CFG analysis crucial in determining the security precision of a given CFI mechanism. They classified prior work on precision of the static analysis into increasing order of static analysis precision (SAP), from SAP.F.0 (No forward branch validation) to SAP.F.6( supports dynamic analysis) for forward control-flow analysis precision. For backward control-flow precision, the classification are SAP.B.0 (No backward branch validation), SAP.B.1(Labeling equivalent classes) and SAP.B.2 (Shadow stack). They hope to achieve a more precise and consistent taxonomy this way as opposed to the fine-gained/coarse-grained classification used in prior work within the CFI research community.  
\newline
\newline
Using the proposed classifications on control-flow transfers and static analysis precision, they qualitatively analyzed the theoretical security guarantees of different existing CFI mechanisms in publications. They also gave quantitative evaluation of the security precision of several CFI implementations. The CFI mechanisms were evaluated qualitatively on four dimensions namely: supported control-flow transfers (CF), reported implementation overhead (RP), static analysis precision on forward control-flows (SAP.F) and static analysis precision of backward control-flows (SAP.B). Each of the mechanisms were evaluated on four axes on a spider plot, each axis corresponding to one of the dimensions. They stated that the area under the spider plot gives a rough estimate of the precision of a given mechanism. They noted that both forward and backward control-flow transfers must be considered when analyzing the precision of a given implementation. Therefore implementations such as SafeDispatch, T-VIP, VTV, IFCC, vfGuard and VTint have a precision of SAP.B.0 in the SAP.B dimension since they did not consider backward control-flow transfers. They also noted that most implementations use labels to distinguish equivalent classes. This leads to loss of precision in the static analysis since.....with the exception being $\pi$CFI which uses dynamic information to activate CFG edges, scoring SAP.F.6. $\pi$CFI received the highest precision. Implementations that received high precision are those that use context-sensitivity processing of CFG in the forward control-flow transfer and also has a high backward control flow precision such as shadow stack. Such implementations include RochJIT, MCFI, PathArmor and Lockdown. Their contribution to quantitative measure of CFI security was a metric which is directly proportional to the number of equivalent classes (LC) and inversely proportional to the size of the largest class (LC) as shown in Equation \ref{sec}. 

\begin{eqnarray}
QuantitativeSecurity &=& EC * \frac{1}{LC}
\label{sec}
\end{eqnarray}
\nolinebreak
They argued that an implementation with a large number of small equivalent classes is more secure than an implementation with a small number of large equivalent classes. Hence, Equation \ref{sec} provides a more meaningful measure than Average Indirect Target Reduction (AIR) which gives the average reduction of allowed targets. Against this novel quantitative matric, they eval
\newline
\newline







 
%\begin{thebibliography}{99}

%\bibitem{gonzalez2012} Jonay I. Gonz\'{a}lez Hern\'{a}ndez, 
%Pilar Ruiz-Lapuente,	
%Hugo M. Tabernero,	
%David Montes,	
%Ramon Canal,	
%Javier M\'{e}ndez	
%and Luigi R. Bedin,
%{No surviving evolved companions of the progenitor of SN1006},
%Nature, {\bf 489}, 533-536 (2012).

%\end{thebibliography}

\bibliographystyle{plain}
\bibliography{References}



\end{document}
